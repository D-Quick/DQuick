<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>gl3n.math</title>
        </head><body>
        <h1>gl3n.math</h1>
        <!-- Generated by Ddoc from ..\src\dquick\etc\gl3n\gl3n\math.d -->
gl3n.<u>math</u>
<br><br>
Provides nearly all GLSL functions, according to spec 4.1,
it also publically imports other useful functions (from std.<u>math</u>, core.stdc.<u>math</u>, std.alogrithm)
so you only have to import this file to get all mathematical functions you need.
<br><br>

Publically imports: PI, sin, cos, tan, asin, acos, atan, atan2, sinh, cosh, tanh,
asinh, acosh, atanh, pow, exp, log, exp2, log2, sqrt, abs, floor, trunc, round, ceil, modf,
fmodf, min, max.

<br><br>
<b>Authors:</b><br>
David Herberth
<br><br>
<b>License:</b><br>
MIT<br><br>

<dl><dt><big><a name="PI_180"></a>real <u>PI_180</u>;
</big></dt>
<dd>PI / 180 at compiletime, used for degrees/radians conversion.<br><br>

</dd>
<dt><big><a name="_180_PI"></a>real <u>_180_PI</u>;
</big></dt>
<dd>180 / PI at compiletime, used for degrees/radians conversion.<br><br>

</dd>
<dt><big><a name="mod"></a>T <u>mod</u>(T)(T <i>x</i>, T <i>y</i>);
</big></dt>
<dd>Modulus. Returns x - y * floor(x/y).<br><br>

</dd>
<dt><big><a name="abs"></a>T <u>abs</u>(T)(T <i>t</i>);
</big></dt>
<dd>Calculates the absolute value.<br><br>

</dd>
<dt><big><a name="abs"></a>T <u>abs</u>(T)(T <i>vec</i>);
<br><a name="abs"></a>T <u>abs</u>(T)(T <i>quat</i>);
</big></dt>
<dd>Calculates the absolute value per component.<br><br>

</dd>
<dt><big><a name="inversesqrt"></a>pure nothrow @safe real <u>inversesqrt</u>(real <i>x</i>);
</big></dt>
<dd>Returns 1/sqrt(<i>x</i>), results are undefined if <i>x</i> &lt;= 0.<br><br>

</dd>
<dt><big><a name="sign"></a>float <u>sign</u>(T)(T <i>x</i>);
</big></dt>
<dd>Returns 1.0 if x &gt; 0, 0.0 if x = 0, or -1.0 if x &lt; 0.<br><br>

</dd>
<dt><big><a name="almost_equal"></a>bool <u>almost_equal</u>(T, S)(T <i>a</i>, S <i>b</i>, float <i>epsilon</i> = 1e-06F);
<br><a name="almost_equal"></a>bool <u>almost_equal</u>(T, S)(T <i>a</i>, S <i>b</i>, float <i>epsilon</i> = 1e-06F);
</big></dt>
<dd>Compares to values and returns <b>true</b> if the difference is epsilon or smaller.<br><br>

</dd>
<dt><big><a name="radians"></a>pure nothrow @safe real <u>radians</u>(real <i>degrees</i>);
</big></dt>
<dd>Converts <i>degrees</i> to <u>radians</u>.<br><br>

</dd>
<dt><big><a name="cradians"></a>real <u>cradians</u>(real degrees)();
</big></dt>
<dd>Compiletime version of <i>radians</i>.<br><br>

</dd>
<dt><big><a name="degrees"></a>pure nothrow @safe real <u>degrees</u>(real <i>radians</i>);
</big></dt>
<dd>Converts <i>radians</i> to <u>degrees</u>.<br><br>

</dd>
<dt><big><a name="cdegrees"></a>real <u>cdegrees</u>(real radians)();
</big></dt>
<dd>Compiletime version of <i>degrees</i>.<br><br>

</dd>
<dt><big><a name="clamp"></a>auto <u>clamp</u>(T1, T2, T3)(T1 <i>x</i>, T2 <i>min_val</i>, T3 <i>max_val</i>);
</big></dt>
<dd>Returns min(max(x, min_val), max_val), Results are undefined if min_val &gt; max_val.<br><br>

</dd>
<dt><big><a name="step"></a>float <u>step</u>(T1, T2)(T1 <i>edge</i>, T2 <i>x</i>);
</big></dt>
<dd>Returns 0.0 if x &lt; edge, otherwise it returns 1.0.<br><br>

</dd>
<dt><big><a name="smoothstep"></a>auto <u>smoothstep</u>(T1, T2, T3)(T1 <i>edge0</i>, T2 <i>edge1</i>, T3 <i>x</i>);
</big></dt>
<dd>Returns 0.0 if x &lt;= edge0 and 1.0 if x &gt;= edge1 and performs smooth 
 hermite interpolation between 0 and 1 when edge0 &lt; x &lt; edge1. 
 This is useful in cases where you would want a threshold function with a smooth transition.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
