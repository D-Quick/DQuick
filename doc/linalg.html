<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>gl3n.linalg</title>
        </head><body>
        <h1>gl3n.linalg</h1>
        <!-- Generated by Ddoc from ..\src\dquick\etc\gl3n\gl3n\linalg.d -->
gl3n.<u>linalg</u>
<br><br>
Special thanks to:
<ul> <li>Tomasz Stachowiak (h3r3tic): allowed me to use parts of <a href="https://bitbucket.org/h3r3tic/boxen/src/default/src/xf/omg">omg</a>.</li>
  <li>Jakob Ã˜vrum (jA_cOp): improved the code a lot!</li>
  <li>Florian Boesch (__doc__): helps me to understand opengl/complex maths better, see: <a href="http://codeflow.org/">http://codeflow.org/</a>.</li>
  <li>#D on freenode: answered general questions about D.</li>
</ul>

<br><br>
<b>Authors:</b><br>
David Herberth
<br><br>
<b>License:</b><br>
MIT

<br><br>
<b>Note:</b><br>
All methods marked with pure are weakly pure since, they all access an instance member.
All static methods are strongly pure.<br><br>

<dl><dt><big><a name="Vector"></a>struct <u>Vector</u>(type, int dimension_) if (dimension_ &gt;= 2 &amp;&amp; dimension_ &lt;= 4);
</big></dt>
<dd>Base template for all vector-types.
<br><br>
<b>Params:</b><br>
<table><tr><td>type</td>
<td>all values get stored as this type</td></tr>
<tr><td>dimension</td>
<td>specifies the dimension of the vector, can be 1, 2, 3 or 4</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>Vector</u>!(<font color=blue>int</font>, 3) vec3i;
<font color=blue>alias</font> <u>Vector</u>!(<font color=blue>float</font>, 4) vec4;
<font color=blue>alias</font> <u>Vector</u>!(<font color=blue>real</font>, 2) vec2r;
</pre>
<br><br>

<dl><dt><big><a name="vt"></a>alias <u>vt</u> = type;
</big></dt>
<dd>Holds the internal type of the vector.<br><br>

</dd>
<dt><big><a name="dimension"></a>int <u>dimension</u>;
</big></dt>
<dd>Holds the <u>dimension</u> of the vector.<br><br>

</dd>
<dt><big><a name="vector"></a>vt[dimension] <u>vector</u>;
</big></dt>
<dd>Holds all coordinates, length conforms dimension.<br><br>

</dd>
<dt><big><a name="value_ptr"></a>@property auto <u>value_ptr</u>();
</big></dt>
<dd>Returns a pointer to the coordinates.<br><br>

</dd>
<dt><big><a name="as_string"></a>string <u>as_string</u>();
<br><a name="toString"></a>alias <u>toString</u> = as_string;
</big></dt>
<dd>Returns the current vector formatted as string, useful for printing the vector.<br><br>

</dd>
<dt><big><a name="x"></a>alias <u>x</u> = get_!('<u>x</u>');
<br><a name="y"></a>alias <u>y</u> = get_!('<u>y</u>');
<br><a name="u"></a>alias <u>u</u> = x;
<br><a name="v"></a>alias <u>v</u> = y;
<br><a name="s"></a>alias <u>s</u> = x;
<br><a name="t"></a>alias <u>t</u> = y;
<br><a name="r"></a>alias <u>r</u> = x;
<br><a name="g"></a>alias <u>g</u> = y;
<br><a name="z"></a>alias <u>z</u> = get_!('<u>z</u>');
<br><a name="b"></a>alias <u>b</u> = z;
<br><a name="p"></a>alias <u>p</u> = z;
<br><a name="w"></a>alias <u>w</u> = get_!('<u>w</u>');
<br><a name="a"></a>alias <u>a</u> = w;
<br><a name="q"></a>alias <u>q</u> = w;
</big></dt>
<dd>static properties to access the values.<br><br>

</dd>
<dt><big><a name="this"></a> this(Args...)(Args <i>args</i>);
<br><a name="this"></a> this(T)(T <i>vec</i>);
<br><a name="this"></a> this()(vt <i>value</i>);
</big></dt>
<dd>Constructs the vector.
 If a single value is passed the vector, the vector will be cleared with this value.
 If a vector with a higher dimension is passed the vector will hold the first values up to its dimension.
 If mixed types are passed they will be joined together (allowed types: vector, static array, <i>vt</i>).
<br><br>
<b>Examples:</b><br>
<pre class="d_code">vec4 v4 = vec4(1.0f, vec2(2.0f, 3.0f), 4.0f);
vec3 v3 = vec3(v4); <font color=green>// v3 = vec3(1.0f, 2.0f, 3.0f);
</font>vec2 v2 = v3.xy; <font color=green>// swizzling returns a static array.
</font>vec3 v3_2 = vec3(1.0f); <font color=green>// vec3 v3_2 = vec3(1.0f, 1.0f, 1.0f);
</font></pre>
<br><br>

</dd>
<dt><big><a name="ok"></a>const bool <u>ok</u>();
</big></dt>
<dd>Returns <b>true</b> if all values are not nan and finite, otherwise <b>false</b>.<br><br>

</dd>
<dt><big><a name="clear"></a>void <u>clear</u>(vt <i>value</i>);
</big></dt>
<dd>Sets all values of the vector to <i>value</i>.<br><br>

</dd>
<dt><big><a name="update"></a>void <u>update</u>(Vector!(vt, dimension) <i>other</i>);
</big></dt>
<dd>Updates the vector with the values from <i>other</i>.<br><br>

</dd>
<dt><big><a name="opDispatch"></a>const vt[s.length] <u>opDispatch</u>(string s)();
</big></dt>
<dd>Implements dynamic swizzling.
<br><br>
<b>Returns:</b><br>
a static array of coordinates.<br><br>

</dd>
<dt><big><a name="magnitude_squared"></a>const real <u>magnitude_squared</u>();
</big></dt>
<dd>Returns the squared magnitude of the vector.<br><br>

</dd>
<dt><big><a name="magnitude"></a>const real <u>magnitude</u>();
<br><a name="length_squared"></a>alias <u>length_squared</u> = magnitude_squared;
<br><a name="length"></a>alias <u>length</u> = magnitude;
</big></dt>
<dd>Returns the <u>magnitude</u> of the vector.<br><br>

</dd>
<dt><big><a name="normalize"></a>void <u>normalize</u>();
</big></dt>
<dd>Normalizes the vector.<br><br>

</dd>
<dt><big><a name="normalized"></a>const Vector <u>normalized</u>();
</big></dt>
<dd>Returns a <u>normalized</u> copy of the current vector.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="dot"></a>T.vt <u>dot</u>(T)(const T <i>veca</i>, const T <i>vecb</i>);
</big></dt>
<dd>Calculates the product between two vectors.<br><br>

</dd>
<dt><big><a name="cross"></a>T <u>cross</u>(T)(const T <i>veca</i>, const T <i>vecb</i>);
</big></dt>
<dd>Calculates the <u>cross</u> product of two 3-dimensional vectors.<br><br>

</dd>
<dt><big><a name="distance"></a>T.vt <u>distance</u>(T)(const T <i>veca</i>, const T <i>vecb</i>);
</big></dt>
<dd>Calculates the <u>distance</u> between two vectors.<br><br>

</dd>
<dt><big><a name="vec2"></a>alias <u>vec2</u> = Vector!(float, 2).Vector;
<br><a name="vec3"></a>alias <u>vec3</u> = Vector!(float, 3).Vector;
<br><a name="vec4"></a>alias <u>vec4</u> = Vector!(float, 4).Vector;
<br><a name="vec2d"></a>alias <u>vec2d</u> = Vector!(double, 2).Vector;
<br><a name="vec3d"></a>alias <u>vec3d</u> = Vector!(double, 3).Vector;
<br><a name="vec4d"></a>alias <u>vec4d</u> = Vector!(double, 4).Vector;
<br><a name="vec2i"></a>alias <u>vec2i</u> = Vector!(int, 2).Vector;
<br><a name="vec3i"></a>alias <u>vec3i</u> = Vector!(int, 3).Vector;
<br><a name="vec4i"></a>alias <u>vec4i</u> = Vector!(int, 4).Vector;
</big></dt>
<dd>Pre-defined vector types, the number represents the dimension and the last letter the type (none = float, d = double, i = int).<br><br>

</dd>
<dt><big><a name="Matrix"></a>struct <u>Matrix</u>(type, int rows_, int cols_) if (rows_ &gt; 0 &amp;&amp; cols_ &gt; 0);
</big></dt>
<dd>Base template for all matrix-types.
<br><br>
<b>Params:</b><br>
<table><tr><td>type</td>
<td>all values get stored as this type</td></tr>
<tr><td>rows_</td>
<td>rows of the matrix</td></tr>
<tr><td>cols_</td>
<td>columns of the matrix</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>alias</font> <u>Matrix</u>!(<font color=blue>float</font>, 4, 4) mat4;
<font color=blue>alias</font> <u>Matrix</u>!(<font color=blue>double</font>, 3, 4) mat34d;
<font color=blue>alias</font> <u>Matrix</u>!(<font color=blue>real</font>, 2, 2) mat2r;
</pre>
<br><br>

<dl><dt><big><a name="mt"></a>alias <u>mt</u> = type;
</big></dt>
<dd>Holds the internal type of the matrix;<br><br>

</dd>
<dt><big><a name="rows"></a>int <u>rows</u>;
</big></dt>
<dd>Holds the number of <u>rows</u>;<br><br>

</dd>
<dt><big><a name="cols"></a>int <u>cols</u>;
</big></dt>
<dd>Holds the number of columns;<br><br>

</dd>
<dt><big><a name="matrix"></a>mt[cols][rows] <u>matrix</u>;
</big></dt>
<dd>Holds the <u>matrix</u> <font color=red>row-major</font> in memory.<br><br>

</dd>
<dt><big><a name="value_ptr"></a>@property auto <u>value_ptr</u>();
</big></dt>
<dd>Returns the pointer to the stored values as OpenGL requires it.
 Note this will return a pointer to a <font color=red>row-major</font> matrix, 
 <font color=red>this means you've to set the transpose argument to GL_TRUE when passing it to OpenGL</font>.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=green>// 3rd argument = GL_TRUE
</font>glUniformMatrix4fv(programs.main.model, 1, GL_TRUE, mat4.translation(-0.5f, -0.5f, 1.0f).<u>value_ptr</u>);
</pre>
<br><br>

</dd>
<dt><big><a name="as_string"></a>string <u>as_string</u>();
<br><a name="toString"></a>alias <u>toString</u> = as_string;
</big></dt>
<dd>Returns the current matrix formatted as flat string.<br><br>

</dd>
<dt><big><a name="as_pretty_string"></a>string <u>as_pretty_string</u>();
<br><a name="toPrettyString"></a>alias <u>toPrettyString</u> = as_pretty_string;
</big></dt>
<dd>Returns the current matrix as pretty formatted string. <br><br>

</dd>
<dt><big><a name="this"></a> this(Args...)(Args <i>args</i>);
<br><a name="this"></a> this(T)(T <i>mat</i>);
<br><a name="this"></a> this(T)(T <i>mat</i>);
<br><a name="this"></a> this()(mt <i>value</i>);
</big></dt>
<dd>Constructs the matrix:
 If a single value is passed, the matrix will be cleared with this value (each column in each row will contain this value).
 If a matrix with more rows and columns is passed, the matrix will be the upper left nxm matrix.
 If a matrix with less rows and columns is passed, the passed matrix will be stored in the upper left of an identity matrix.
 It's also allowed to pass vectors and scalars at a time, but the vectors dimension must match the number of columns and align correctly.
<br><br>
<b>Examples:</b><br>
<pre class="d_code">mat2 m2 = mat2(0.0f); <font color=green>// mat2 m2 = mat2(0.0f, 0.0f, 0.0f, 0.0f);
</font>mat3 m3 = mat3(m2); <font color=green>// mat3 m3 = mat3(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f);
</font>mat3 m3_2 = mat3(vec3(1.0f, 2.0f, 3.0f), 4.0f, 5.0f, 6.0f, vec3(7.0f, 8.0f, 9.0f));
mat4 m4 = mat4.identity; <font color=green>// just an identity matrix
</font>mat3 m3_3 = mat3(m4); <font color=green>// mat3 m3_3 = mat3.identity
</font></pre>
<br><br>

</dd>
<dt><big><a name="ok"></a>const bool <u>ok</u>();
</big></dt>
<dd>Returns <b>true</b> if all values are not nan and finite, otherwise <b>false</b>.<br><br>

</dd>
<dt><big><a name="clear"></a>void <u>clear</u>(mt <i>value</i>);
</big></dt>
<dd>Sets all values of the matrix to <i>value</i> (each column in each row will contain this <i>value</i>).<br><br>

</dd>
<dt><big><a name="make_identity"></a>void <u>make_identity</u>();
</big></dt>
<dd>Makes the current matrix an identity matrix.<br><br>

</dd>
<dt><big><a name="identity"></a>Matrix <u>identity</u>();
</big></dt>
<dd>Returns a <u>identity</u> matrix.<br><br>

</dd>
<dt><big><a name="transpose"></a>void <u>transpose</u>();
</big></dt>
<dd>Transposes the current matrix;<br><br>

</dd>
<dt><big><a name="transposed"></a>const Matrix <u>transposed</u>();
</big></dt>
<dd>Returns a <u>transposed</u> copy of the matrix.<br><br>

</dd>
<dt><big><a name="rotation"></a>Matrix <u>rotation</u>(real <i>alpha</i>, Vector!(mt, 3) <i>axis</i>);
<br><a name="rotation"></a>Matrix <u>rotation</u>(real <i>alpha</i>, mt <i>x</i>, mt <i>y</i>, mt <i>z</i>);
</big></dt>
<dd>Returns an identity matrix with an applied rotate_axis around an arbitrary <i>axis</i> (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="xrotation"></a>Matrix <u>xrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns an identity matrix with an applied rotation around the x-axis (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="yrotation"></a>Matrix <u>yrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns an identity matrix with an applied rotation around the y-axis (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="zrotation"></a>Matrix <u>zrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns an identity matrix with an applied rotation around the z-axis (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="rotatex"></a>Matrix <u>rotatex</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current matrix around the x-axis and returns <i>this</i> (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="rotatey"></a>Matrix <u>rotatey</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current matrix around the y-axis and returns <i>this</i> (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="rotatez"></a>Matrix <u>rotatez</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current matrix around the z-axis and returns <i>this</i> (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="translation"></a>void <u>translation</u>(mt[] <i>values</i>...);
</big></dt>
<dd>Sets the <u>translation</u> of the matrix (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="translation"></a>void <u>translation</u>(Matrix <i>mat</i>);
</big></dt>
<dd>Copyies the <u>translation</u> from <i>mat</i> to the current matrix (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="translation"></a>Matrix <u>translation</u>();
</big></dt>
<dd>Returns an identity matrix with the current <u>translation</u> applied (nxn matrices, n &gt;= 3)..<br><br>

</dd>
<dt><big><a name="scale"></a>void <u>scale</u>(mt[] <i>values</i>...);
</big></dt>
<dd>Sets the <u>scale</u> of the matrix (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="scale"></a>void <u>scale</u>(Matrix <i>mat</i>);
</big></dt>
<dd>Copyies the <u>scale</u> from <i>mat</i> to the current matrix (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="scale"></a>Matrix <u>scale</u>();
</big></dt>
<dd>Returns an identity matrix with the current <u>scale</u> applied (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="rotation"></a>void <u>rotation</u>(Matrix!(mt, 3, 3) <i>rot</i>);
</big></dt>
<dd>Copies <i>rot</i> into the upper left corner, the translation (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="rotation"></a>Matrix!(mt, 3, 3) <u>rotation</u>();
</big></dt>
<dd>Returns an identity matrix with the current <u>rotation</u> applied (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big><a name="inverse"></a>const Matrix <u>inverse</u>();
</big></dt>
<dd>Returns an inverted copy of the current matrix (nxn matrices, n &lt;= 4).<br><br>

</dd>
<dt><big><a name="invert"></a>void <u>invert</u>();
</big></dt>
<dd>Inverts the current matrix (nxn matrices, n &lt;= 4).<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="mat2"></a>alias <u>mat2</u> = Matrix!(float, 2, 2).Matrix;
</big></dt>
<dd>Pre-defined matrix types, the first number represents the number of rows 
 and the second the number of columns, if there's just one it's a nxn matrix.
 All of these matrices are floating-point matrices.<br><br>

</dd>
<dt><big><a name="Quaternion"></a>struct <u>Quaternion</u>(type);
</big></dt>
<dd>Base template for all quaternion-types.
<br><br>
<b>Params:</b><br>
<table><tr><td>type</td>
<td>all values get stored as this type</td></tr>
</table><br>

<dl><dt><big><a name="qt"></a>alias <u>qt</u> = type;
</big></dt>
<dd>Holds the internal type of the quaternion.<br><br>

</dd>
<dt><big><a name="quaternion"></a>qt[4] <u>quaternion</u>;
</big></dt>
<dd>Holds the w, x, y and z coordinates.<br><br>

</dd>
<dt><big><a name="value_ptr"></a>@property auto <u>value_ptr</u>();
</big></dt>
<dd>Returns a pointer to the quaternion in memory, it starts with the w coordinate.<br><br>

</dd>
<dt><big><a name="as_string"></a>string <u>as_string</u>();
</big></dt>
<dd>Returns the current vector formatted as string, useful for printing the quaternion.<br><br>

</dd>
<dt><big><a name="w"></a>alias <u>w</u> = get_!('<u>w</u>');
<br><a name="x"></a>alias <u>x</u> = get_!('<u>x</u>');
<br><a name="y"></a>alias <u>y</u> = get_!('<u>y</u>');
<br><a name="z"></a>alias <u>z</u> = get_!('<u>z</u>');
</big></dt>
<dd>static properties to access the values.<br><br>

</dd>
<dt><big><a name="this"></a> this(qt <i>w_</i>, qt <i>x_</i>, qt <i>y_</i>, qt <i>z_</i>);
<br><a name="this"></a> this(qt <i>w_</i>, Vector!(qt, 3) <i>vec</i>);
<br><a name="this"></a> this(Vector!(qt, 4) <i>vec</i>);
</big></dt>
<dd>Constructs the quaternion.
 Takes a 4-dimensional vector, where vector.x = the quaternions w coordinate,
 or a w coordinate of type <i>qt</i> and a 3-dimensional vector representing the imaginary part,
 or 4 values of type <i>qt</i>.<br><br>

</dd>
<dt><big><a name="ok"></a>const bool <u>ok</u>();
</big></dt>
<dd>Returns <b>true</b> if all values are not nan and finite, otherwise <b>false</b>.<br><br>

</dd>
<dt><big><a name="magnitude_squared"></a>const real <u>magnitude_squared</u>();
</big></dt>
<dd>Returns the squared magnitude of the quaternion.<br><br>

</dd>
<dt><big><a name="magnitude"></a>const real <u>magnitude</u>();
</big></dt>
<dd>Returns the <u>magnitude</u> of the quaternion.<br><br>

</dd>
<dt><big><a name="identity"></a>Quaternion <u>identity</u>();
</big></dt>
<dd>Returns an <u>identity</u> quaternion (w=1, x=0, y=0, z=0).<br><br>

</dd>
<dt><big><a name="make_identity"></a>void <u>make_identity</u>();
</big></dt>
<dd>Makes the current quaternion an identity quaternion.<br><br>

</dd>
<dt><big><a name="invert"></a>void <u>invert</u>();
<br><a name="conjugate"></a>alias <u>conjugate</u> = invert;
</big></dt>
<dd>Inverts the quaternion.<br><br>

</dd>
<dt><big><a name="inverse"></a>const Quaternion <u>inverse</u>();
<br><a name="conjugated"></a>alias <u>conjugated</u> = inverse;
</big></dt>
<dd>Returns an inverted copy of the current quaternion.<br><br>

</dd>
<dt><big><a name="from_matrix"></a>Quaternion <u>from_matrix</u>(Matrix!(qt, 3, 3) <i>matrix</i>);
</big></dt>
<dd>Creates a quaternion from a 3x3 <i>matrix</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>Matrix!(qt, 3, 3) <i>matrix</i></td>
<td>3x3 <i>matrix</i> (rotation)</td></tr>
</table><br>
<b>Returns:</b><br>
A quaternion representing the rotation (3x3 <i>matrix</i>)<br><br>

</dd>
<dt><big><a name="to_matrix"></a>const Matrix!(qt, rows, cols) <u>to_matrix</u>(int rows, int cols)();
</big></dt>
<dd>Returns the quaternion as matrix.
<br><br>
<b>Params:</b><br>
<table><tr><td>rows</td>
<td>number of rows of the resulting matrix (min 3)</td></tr>
<tr><td>cols</td>
<td>number of columns of the resulting matrix (min 3)</td></tr>
</table><br>

</dd>
<dt><big><a name="normalize"></a>void <u>normalize</u>();
</big></dt>
<dd>Normalizes the current quaternion.<br><br>

</dd>
<dt><big><a name="normalized"></a>const Quaternion <u>normalized</u>();
</big></dt>
<dd>Returns a <u>normalized</u> copy of the current quaternion.<br><br>

</dd>
<dt><big><a name="yaw"></a>const real <u>yaw</u>();
</big></dt>
<dd>Returns the <u>yaw</u>.<br><br>

</dd>
<dt><big><a name="pitch"></a>const real <u>pitch</u>();
</big></dt>
<dd>Returns the <u>pitch</u>.<br><br>

</dd>
<dt><big><a name="roll"></a>const real <u>roll</u>();
</big></dt>
<dd>Returns the <u>roll</u>.<br><br>

</dd>
<dt><big><a name="xrotation"></a>Quaternion <u>xrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns a quaternion with applied rotation around the x-axis.<br><br>

</dd>
<dt><big><a name="yrotation"></a>Quaternion <u>yrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns a quaternion with applied rotation around the y-axis.<br><br>

</dd>
<dt><big><a name="zrotation"></a>Quaternion <u>zrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns a quaternion with applied rotation around the z-axis.<br><br>

</dd>
<dt><big><a name="axis_rotation"></a>Quaternion <u>axis_rotation</u>(real <i>alpha</i>, Vector!(qt, 3) <i>axis</i>);
</big></dt>
<dd>Returns a quaternion with applied rotation around an <i>axis</i>.<br><br>

</dd>
<dt><big><a name="euler_rotation"></a>Quaternion <u>euler_rotation</u>(real <i>heading</i>, real <i>attitude</i>, real <i>bank</i>);
</big></dt>
<dd>Creates a quaternion from an euler rotation.<br><br>

</dd>
<dt><big><a name="rotatex"></a>Quaternion <u>rotatex</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current quaternion around the x-axis and returns <i>this</i>.<br><br>

</dd>
<dt><big><a name="rotatey"></a>Quaternion <u>rotatey</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current quaternion around the y-axis and returns <i>this</i>.<br><br>

</dd>
<dt><big><a name="rotatez"></a>Quaternion <u>rotatez</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current quaternion around the z-axis and returns <i>this</i>.<br><br>

</dd>
<dt><big><a name="rotate_axis"></a>Quaternion <u>rotate_axis</u>(real <i>alpha</i>, Vector!(qt, 3) <i>axis</i>);
</big></dt>
<dd>Rotates the current quaternion around an <i>axis</i> and returns <i>this</i>.<br><br>

</dd>
<dt><big><a name="rotate_euler"></a>Quaternion <u>rotate_euler</u>(real <i>heading</i>, real <i>attitude</i>, real <i>bank</i>);
</big></dt>
<dd>Applies an euler rotation to the current quaternion and returns <i>this</i>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="quat"></a>alias <u>quat</u> = Quaternion!(float).Quaternion;
</big></dt>
<dd>Pre-defined quaternion of type float.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
